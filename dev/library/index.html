<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · Point spread functions for Julia</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Point spread functions for Julia</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li class="is-active"><a class="tocitem" href>Reference</a><ul class="internal"><li><a class="tocitem" href="#PSF-Models-1"><span>PSF Models</span></a></li><li><a class="tocitem" href="#Methods-1"><span>Methods</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/emmt/PointSpreadFunctions.jl/blob/master/docs/src/library.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Reference-1"><a class="docs-heading-anchor" href="#Reference-1">Reference</a><a class="docs-heading-anchor-permalink" href="#Reference-1" title="Permalink"></a></h1><h2 id="PSF-Models-1"><a class="docs-heading-anchor" href="#PSF-Models-1">PSF Models</a><a class="docs-heading-anchor-permalink" href="#PSF-Models-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PointSpreadFunctions.AbstractPSF" href="#PointSpreadFunctions.AbstractPSF"><code>PointSpreadFunctions.AbstractPSF</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Instances of sub-types of <code>PointSpreadFunctions.AbstractPSF{N}</code> are used to store the parameters of various <em>Point Spread Functions</em> (PSF) models, <code>N</code> is the number of parameters.  Let <code>P</code> be such an instance, then:</p><pre><code class="language-none">P([T,] r)
P([T,] x, y)</code></pre><p>yield an approximation of the PSF at a distance <code>r</code> or at a position <code>(x,y)</code> relative to the position of the point source.</p><p>Use index notation to retrieve the parameters as an <code>N</code>-tuple or a specific parameters:</p><pre><code class="language-none">P[:]  # yields all parameters
P[i]  # yields i-th parameter</code></pre><p>The PSF is normalized such that its peak value (usually at the center) is equal to one.  The rationale is that normalization by the peak value does not depend on the dimensionality while the integral of the PSF does depend on the dimensionality.</p><p>See also <a href="#PointSpreadFunctions.AiryPSF"><code>AiryPSF</code></a>, <a href="#PointSpreadFunctions.CauchyPSF"><code>CauchyPSF</code></a>, <a href="#PointSpreadFunctions.GaussianPSF"><code>GaussianPSF</code></a>, <a href="#PointSpreadFunctions.MoffatPSF"><code>MoffatPSF</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/PointSpreadFunctions.jl/blob/e4ae47d3abddd4e39862d41ad6eca8c4b9f54337/src/models.jl#LL15-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PointSpreadFunctions.AiryPSF" href="#PointSpreadFunctions.AiryPSF"><code>PointSpreadFunctions.AiryPSF</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">P = AiryPSF(lim [, ρ=0])</code></pre><p>defines the <em>Point Spread Function</em> (PSF) <code>P</code> of a circular pupil. Argument <code>lim</code> is the distance in the focal plane corresponding to the diffraction limit.  Assuming the distance is given in angular units (radians), <code>lim = λ/D</code> with <code>λ</code> the wavelength and <code>D</code> the pupil diameter (both expressed in the same units).  Optional argument <code>ρ</code> is the ratio of the size of the central obscuration to that of the pupil (necessarily <code>0 ≤ ρ &lt; 1</code>).  If not specified, <code>ρ = 0</code> is assumed (unobstructed pupil).  Then:</p><pre><code class="language-none">P([T,] r)
P([T,] x, y)</code></pre><p>yield the PSF at distance <code>r</code> or position <code>(x,y)</code> relative to the position of the source and normalized so that the peak value of the PSF is one.  Optional argument <code>T</code> is the floating-point type of the result.  Arguments <code>lim</code>, <code>r</code>, <code>x</code> and <code>y</code> are in the same units.</p><p>The peak-normalized Airy PSF at distance <code>r</code> is given by:</p><pre><code class="language-none">P(r) = ((a/(c*r))*(J1(c*r) - ρ*J1(ρ*c*r)))^2</code></pre><p>with <code>a = 2/(1 - ρ^2)</code>, <code>c = π/lim</code> and <code>J1</code> the Bessel function of the first kind.</p><p>See also <a href="#PointSpreadFunctions.CauchyPSF"><code>CauchyPSF</code></a>, <a href="#PointSpreadFunctions.GaussianPSF"><code>GaussianPSF</code></a>, <a href="#PointSpreadFunctions.MoffatPSF"><code>MoffatPSF</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/PointSpreadFunctions.jl/blob/e4ae47d3abddd4e39862d41ad6eca8c4b9f54337/src/models.jl#LL79-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PointSpreadFunctions.CauchyPSF" href="#PointSpreadFunctions.CauchyPSF"><code>PointSpreadFunctions.CauchyPSF</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">P = CauchyPSF(fwhm)</code></pre><p>defines a Cauchy <em>Point Spread Function</em> (PSF) <code>P</code> (or Lorentzian) of full width at half maximum <code>fwhm</code> which can be used as:</p><pre><code class="language-none">P([T,] r)
P([T,] x, y)</code></pre><p>to compute the PSF at distance <code>r</code> or position <code>(x,y)</code> relative to the position of the source and normalized so that the peak value of the PSF is one.  Optional argument <code>T</code> is the floating-point type of the result. Arguments <code>fwhm</code>, <code>r</code>, <code>x</code> and <code>y</code> are in the same units.</p><p>The peak-normalized Cauchy PSF at distance <code>r</code> is given by:</p><pre><code class="language-none">P(r) = q/(q + r^2)</code></pre><p>with <code>q = (fwhm/2)^2</code>.</p><p>See also <a href="#PointSpreadFunctions.AiryPSF"><code>AiryPSF</code></a>, <a href="#PointSpreadFunctions.GaussianPSF"><code>GaussianPSF</code></a>, <a href="#PointSpreadFunctions.MoffatPSF"><code>MoffatPSF</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/PointSpreadFunctions.jl/blob/e4ae47d3abddd4e39862d41ad6eca8c4b9f54337/src/models.jl#LL243-L265">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PointSpreadFunctions.GaussianPSF" href="#PointSpreadFunctions.GaussianPSF"><code>PointSpreadFunctions.GaussianPSF</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">P = GaussianPSF(fwhm)</code></pre><p>defines a Gaussian <em>Point Spread Function</em> (PSF) <code>P</code> of full width at half maximum <code>fwhm</code> which can be used as:</p><pre><code class="language-none">P([T,] r)
P([T,] x, y)</code></pre><p>to compute the PSF at distance <code>r</code> or position <code>(x,y)</code> relative to the position of the source and normalized so that the peak value of the PSF is one.  Optional argument <code>T</code> is the floating-point type of the result. Arguments <code>fwhm</code>, <code>r</code>, <code>x</code> and <code>y</code> are in the same units.</p><p>The peak-normalized Gaussian PSF at distance <code>r</code> is given by:</p><pre><code class="language-none">P(r) = exp(q*r^2)</code></pre><p>with <code>q = -4*log(2)/fwhm^2</code>.</p><p>See also <a href="#PointSpreadFunctions.AiryPSF"><code>AiryPSF</code></a>, <a href="#PointSpreadFunctions.CauchyPSF"><code>CauchyPSF</code></a>, <a href="#PointSpreadFunctions.MoffatPSF"><code>MoffatPSF</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/PointSpreadFunctions.jl/blob/e4ae47d3abddd4e39862d41ad6eca8c4b9f54337/src/models.jl#LL314-L336">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PointSpreadFunctions.MoffatPSF" href="#PointSpreadFunctions.MoffatPSF"><code>PointSpreadFunctions.MoffatPSF</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">P = MoffatPSF(fwhm, beta)</code></pre><p>defines a Moffat PSF <code>P</code> of full width at half maximum <code>fwhm</code> and exponent <code>beta</code> which can be used as:</p><pre><code class="language-none">P([T,] r)
P([T,] x, y)</code></pre><p>to compute the PSF at distance <code>r</code> or position <code>(x,y)</code> relative to the position of the source and normalized so that the peak value of the PSF is one.  Optional argument <code>T</code> is the floating-point type of the result. Arguments <code>fwhm</code>, <code>r</code>, <code>x</code> and <code>y</code> are in the same units.</p><p>The peak-normalized Moffat PSF at distance <code>r</code> is given by:</p><pre><code class="language-none">P(r) = (1 + q*r^2)^(-beta)</code></pre><p>with <code>q = (2^(1/beta) - 1)*(2/fwhm)^2</code>.</p><p>See also <a href="#PointSpreadFunctions.AiryPSF"><code>AiryPSF</code></a>, <a href="#PointSpreadFunctions.CauchyPSF"><code>CauchyPSF</code></a>, <a href="#PointSpreadFunctions.GaussianPSF"><code>GaussianPSF</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/PointSpreadFunctions.jl/blob/e4ae47d3abddd4e39862d41ad6eca8c4b9f54337/src/models.jl#LL389-L411">source</a></section></article><h2 id="Methods-1"><a class="docs-heading-anchor" href="#Methods-1">Methods</a><a class="docs-heading-anchor-permalink" href="#Methods-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="PointSpreadFunctions.getfwhm" href="#PointSpreadFunctions.getfwhm"><code>PointSpreadFunctions.getfwhm</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">getfwhm(P)</code></pre><p>yields the full width at half maximum (FWHM) of point spread function <code>P</code>. Computing the result may require some calculations, so it is better to save the result if this value must be used several times.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/PointSpreadFunctions.jl/blob/e4ae47d3abddd4e39862d41ad6eca8c4b9f54337/src/models.jl#LL49-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PointSpreadFunctions.findzeros" href="#PointSpreadFunctions.findzeros"><code>PointSpreadFunctions.findzeros</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">findzeros([T=Float64,] P, n; kwds...)</code></pre><p>yield the <code>n</code>-th zero of <em>Point Spread Function</em> (PSF) <code>P</code>.  If <code>n</code> is a vector of integers, a vector with the corresponding zeros is returned. For example:</p><pre><code class="language-none">findzeros(P, 1:3)</code></pre><p>yields the first 3 zeros of <code>P</code>.</p><p>Optional argument <code>T</code> can be used to specify the floating-point type of the result.  The keywords of <code>OptimPack.fzero</code> can be specified.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/PointSpreadFunctions.jl/blob/e4ae47d3abddd4e39862d41ad6eca8c4b9f54337/src/models.jl#LL201-L215">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PointSpreadFunctions.fit" href="#PointSpreadFunctions.fit"><code>PointSpreadFunctions.fit</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fit(psf, pos, [wgt,] dat[, roi]; nonnegative=false) -&gt; psf′, pos′</code></pre><p>fits a given <em>Point Spread Function</em> (PSF) model on data <code>dat</code> with (optional) respective weights <code>wgt</code>.  Argument <code>psf</code> is a PSF instance to specify which PSF model to use and its initial parameters.  Argument <code>pos</code> is the initial PSF position.  The result is a 2-tuple with the fitted PSF model and position.</p><p>The fit is carried out by <code>OptimPack.Powell.Newuoa.minimize</code> method.  The initial parameters should be close enough to the solution for the fit to behave correctly.</p><p>Keyword <code>nonnegative</code> indicates whether the intensity of the PSF should be nonnegative or not.  Keyword <code>rho = (rhobeg,rhoend)</code> may be used to specify the initial and final precision on the parameters.  Additional keywords may be specified and are passed to the minimizer.</p><p>An optional <em>Region Of Interest</em> (ROI) may be specified by argument <code>roi</code> as an <code>N</code>-tuple of index ranges or colons.  This is useful to limit the region used to perform the fit.  For example:</p><pre><code class="language-none">fit(GaussianPSF(2.5), (23,12), dat, (10:30, :))</code></pre><p>will fit a Gaussian PSF model on sub-array <code>dat[10:30,:]</code>.  The advantages of specifying a ROI is that the relative position of the ROI is taken into account in the initial and final position and that a view is used instead of extracting a sub-array.  Specifying a ROI also works for weighted data. Non-rectangular ROIs can be emulated by having weights equal to zero where data should be ignored.</p><p>To simply localize the PSF without fitting its parameters, wrap the PSF model with the <code>immutable</code> method:</p><pre><code class="language-none">fit(immutable(psf), pos, [wgt,] dat[, roi]; nonnegative=false)</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The <code>fit</code> and <code>immutable</code> methods are not exported (yet).  They must be prefixed or explicitely exported.  For example:</p><pre><code class="language-none">using PointSpreadFunctions
using PointSpreadFunctions: fit, immutable</code></pre></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/PointSpreadFunctions.jl/blob/e4ae47d3abddd4e39862d41ad6eca8c4b9f54337/src/fitting.jl#LL59-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isvalid-Tuple{AbstractPSF}" href="#Base.isvalid-Tuple{AbstractPSF}"><code>Base.isvalid</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isvalid(psf) -&gt; bool</code></pre><p>yields whether the parameters of the point spread function <code>psf</code> are correct.  The <a href="@ref"><code>check_structure</code></a> method is similar but throws for invalid parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/emmt/PointSpreadFunctions.jl/blob/e4ae47d3abddd4e39862d41ad6eca8c4b9f54337/src/models.jl#LL69-L76">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Missing docstring.</header><div class="admonition-body"><p>Missing docstring for <code>check_structure(::PointSpreadFunctions.AbstractPSF)</code>. Check Documenter&#39;s build log for details.</p></div></div></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Home</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 4 November 2020 08:49">Wednesday 4 November 2020</span>. Using Julia version 1.4.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
